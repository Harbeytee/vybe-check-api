import { Server, Socket } from "socket.io";
import { Server as HttpServer } from "http";
import { connectRedis, getRedisAdapter } from "./socket/redis/client";
import createRoom from "./socket/handlers/room/createRoom";
import joinRoom from "./socket/handlers/room/joinRoom";
import rejoinRoom from "./socket/handlers/room/rejoinRoom";
import startGame from "./socket/handlers/game/startGame";
import flipCard from "./socket/handlers/game/flipCard";
import nextQuestion from "./socket/handlers/game/nextQuestion";
import addCustomQuestion from "./socket/handlers/game/addCustomQuestion";
import removeCustomQuestion from "./socket/handlers/game/removeCustomQuestion";
import disconnect from "./socket/handlers/disconnect";
import heartbeat from "./socket/handlers/room/heartbeat";
import selectPack from "./socket/handlers/game/selectPack";

export const initSocket = async (httpServer: HttpServer) => {
  await connectRedis();

  const io = new Server(httpServer, {
    cors: { origin: "*" },
    adapter: getRedisAdapter(),
    // Connection timeout configuration to detect dead connections
    pingTimeout: 20000, // 20 seconds - time to wait for pong response
    pingInterval: 10000, // 10 seconds - interval between pings
    // This ensures connections are dropped if client doesn't respond
    // Works even when browser suspends tabs
  });

  io.on("connection", (socket: Socket) => {
    // Room events
    socket.on("create_room", createRoom({ socket, io }));
    socket.on("join_room", joinRoom({ io, socket }));
    socket.on("rejoin_room", rejoinRoom({ socket }));
    socket.on("heartbeat", heartbeat({ socket, io }));

    // Game events
    socket.on("select_pack", selectPack({ socket, io }));
    socket.on("start_game", startGame({ io }));
    socket.on("flip_card", flipCard({ io }));
    socket.on("next_question", nextQuestion({ io }));
    socket.on("add_custom_question", addCustomQuestion({ io }));
    socket.on("remove_custom_question", removeCustomQuestion({ io }));

    //disconnect
    socket.on("disconnect", disconnect({ socket, io }));
  });

  return io;
};

// import { Server, Socket } from "socket.io"; import { Server as HttpServer } from "http"; import { nanoid } from "nanoid"; import { createClient } from "redis"; import { createAdapter } from "@socket.io/redis-adapter"; import { mappedGamePacks } from "./utils.ts/data"; import config from "./config/config"; import { Player, Room } from "./types/interfaces"; const ROOM_TTL = 3600; const PLAYER_TTL = 15; const pubClient = createClient({ socket: { host: config.redis.host, port: 11115, keepAlive: true, connectTimeout: 10000, reconnectStrategy: (retries) => Math.min(retries * 100, 3000), }, password: config.redis.password, }); pubClient.on("error", (err) => { console.error("❌ Redis Client Error:", err); }); const subClient = pubClient.duplicate(); subClient.on("error", (err) => { console.error("❌ Redis Sub Client Error:", err); }); Promise.all([pubClient.connect(), subClient.connect()]).then(() => { console.log("✅ Redis Hash-Store Connected"); }); /* ====================================================== HELPERS ====================================================== */ async function getFullRoom(roomCode: string): Promise { const metaKey = `room:${roomCode}:meta`; const playerKey = `room:${roomCode}:players`; const [meta, playersRaw] = await Promise.all([ pubClient.hGetAll(metaKey), pubClient.hGetAll(playerKey), ]); if (!meta || Object.keys(meta).length === 0) return null; const players: Player[] = Object.values(playersRaw) .map((p) => JSON.parse(p)) .sort((a, b) => (a.isHost === b.isHost ? 0 : a.isHost ? -1 : 1)); return { code: roomCode, players, selectedPack: meta.selectedPack || null, isStarted: meta.isStarted === "true", isFlipped: meta.isFlipped === "true", isTransitioning: meta.isTransitioning === "true", currentPlayerIndex: parseInt(meta.currentPlayerIndex || "0"), currentQuestion: meta.currentQuestion || null, answeredQuestions: meta.answeredQuestions ? JSON.parse(meta.answeredQuestions) : [], customQuestions: meta.customQuestions ? JSON.parse(meta.customQuestions) : [], totalQuestions: parseInt(meta.totalQuestions || "0"), } as Room; } async function getRoomWithCleanup(roomCode: string): Promise { const playerKey = `room:${roomCode}:players`; const playersRaw = await pubClient.hGetAll(playerKey); // If no players exist, room is dead if (!playersRaw || Object.keys(playersRaw).length === 0) return null; let needsUpdate = false; // Loop through players and check heartbeat keys for (const socketId of Object.keys(playersRaw)) { const active = await pubClient.exists(`player:${roomCode}:${socketId}`); // Player heartbeat expired → remove them if (!active) { await pubClient.hDel(playerKey, socketId); needsUpdate = true; } } const room = await getFullRoom(roomCode); if (!room || room.players.length === 0) { await pubClient.del([`room:${roomCode}:meta`, `room:${roomCode}:players`]); return null; } if (needsUpdate && !room.players.some((p) => p.isHost)) { room.players[0].isHost = true; await pubClient.hSet( playerKey, room.players[0].id, JSON.stringify(room.players[0]) ); } return room; } /* ====================================================== SOCKET INIT ====================================================== */ export const initSocket = (httpServer: HttpServer) => { const io = new Server(httpServer, { cors: { origin: "*" }, adapter: createAdapter(pubClient, subClient), }); io.on("connection", (socket: Socket) => { //create room socket.on("create_room", async ({ playerName }, cb) => { try { let code = ""; let created = false; let attempts = 0; // Try up to 5 times to generate a unique room code while (!created && attempts < 5) { const candidate = nanoid(6).toUpperCase(); const reserve = await pubClient.set( `room:${candidate}:meta`, "RESERVED", { NX: true, EX: 30 } ); if (reserve === "OK") { code = candidate; created = true; } attempts++; } if (!created) return cb({ success: false, message: "Could not generate code" }); const player: Player = { id: socket.id, name: playerName, isHost: true, lastSeen: Date.now(), }; const pipeline = pubClient.multi(); pipeline.del(`room:${code}:meta`); pipeline.hSet(`room:${code}:meta`, { isStarted: "false", isFlipped: "false", currentPlayerIndex: "0", customQuestions: "[]", answeredQuestions: "[]", }); pipeline.hSet( `room:${code}:players`, socket.id, JSON.stringify(player) ); pipeline.set(`player:${code}:${socket.id}`, "active", { EX: PLAYER_TTL, }); pipeline.expire(`room:${code}:meta`, ROOM_TTL); pipeline.expire(`room:${code}:players`, ROOM_TTL); await pipeline.exec(); socket.data.roomCode = code; socket.join(code); cb({ success: true, room: await getFullRoom(code), player }); } catch (e) { cb({ success: false }); } }); //join room socket.on("join_room", async ({ roomCode, playerName }, cb) => { const code = roomCode.toUpperCase(); const room = await getRoomWithCleanup(code); if (!room) return cb({ success: false, message: "Room not found" }); const player: Player = { id: socket.id, name: playerName, isHost: false, lastSeen: Date.now(), }; // Save player and heartbeat await pubClient.hSet( `room:${code}:players`, socket.id, JSON.stringify(player) ); await pubClient.set(`player:${code}:${socket.id}`, "active", { EX: PLAYER_TTL, }); socket.data.roomCode = code; socket.join(code); const updated = await getFullRoom(code); // Broadcast updated room io.to(code).emit("room_updated", updated); cb({ success: true, room: updated, player }); }); //rejoin room socket.on("rejoin_room", async ({ roomCode, playerName }, cb) => { const code = roomCode.toUpperCase(); const room = await getRoomWithCleanup(code); if (!room) return cb({ success: false, message: "Session expired" }); const existing = room.players.find((p) => p.name === playerName); if (existing) { await pubClient.hDel(`room:${code}:players`, existing.id); existing.id = socket.id; await pubClient.hSet( `room:${code}:players`, socket.id, JSON.stringify(existing) ); await pubClient.set(`player:${code}:${socket.id}`, "active", { EX: PLAYER_TTL, }); socket.data.roomCode = code; socket.join(code); cb({ success: true, room: await getFullRoom(code), player: existing }); } else { cb({ success: false }); } }); //Added Room Broadcast to Heartbeat --- socket.on("heartbeat", async ({ roomCode }) => { if (!roomCode) return; // Mark player as active by refreshing heartbeat await pubClient.set(`player:${roomCode}:${socket.id}`, "active", { EX: PLAYER_TTL, }); // Periodic Broadcast: Clean and sync room state for everyone const room = await getRoomWithCleanup(roomCode); if (room) { io.to(roomCode).emit("room_updated", room); } }); //select pack socket.on("select_pack", async ({ roomCode, packId }) => { const room = await getRoomWithCleanup(roomCode); if (!room || !room.players.find((p) => p.id === socket.id)?.isHost) return; await pubClient.hSet(`room:${roomCode}:meta`, "selectedPack", packId); io.to(roomCode).emit("room_updated", await getFullRoom(roomCode)); }); //start game socket.on("start_game", async ({ roomCode }, cb) => { const room = await getRoomWithCleanup(roomCode); const pack = mappedGamePacks.find((p) => p.id == room?.selectedPack); if (!room || !pack) return cb({ success: false }); const pool = [...pack.questions, ...room.customQuestions]; const first = pool[Math.floor(Math.random() * pool.length)]; await pubClient.hSet(`room:${roomCode}:meta`, { isStarted: "true", currentQuestion: first.text, answeredQuestions: JSON.stringify([first.id]), currentPlayerIndex: Math.floor( Math.random() * room.players.length ).toString(), totalQuestions: pool.length, }); io.to(roomCode).emit("game_started", await getFullRoom(roomCode)); cb({ success: true }); }); //flip card socket.on("flip_card", async ({ roomCode }) => { await pubClient.hSet(`room:${roomCode}:meta`, "isFlipped", "true"); io.to(roomCode).emit("room_updated", await getFullRoom(roomCode)); }); //next question socket.on("next_question", async ({ roomCode }) => { const room = await getRoomWithCleanup(roomCode); if (!room) return; const pack = mappedGamePacks.find((p) => p.id == room.selectedPack); const pool = [...(pack?.questions || []), ...room.customQuestions]; const available = pool.filter( (q) => !room.answeredQuestions.includes(q.id) ); if (available.length === 0) return io.to(roomCode).emit("game_over"); const next = available[Math.floor(Math.random() * available.length)]; await pubClient.hSet(`room:${roomCode}:meta`, { currentQuestion: next.text, isFlipped: "false", answeredQuestions: JSON.stringify([...room.answeredQuestions, next.id]), currentPlayerIndex: ( (room.currentPlayerIndex + 1) % room.players.length ).toString(), }); io.to(roomCode).emit("room_updated", await getFullRoom(roomCode)); }); //add and remove custom question socket.on("add_custom_question", async ({ roomCode, question }) => { const room = await getRoomWithCleanup(roomCode); if (!room) return; const list = [...room.customQuestions, { id: nanoid(), text: question }]; await pubClient.hSet( `room:${roomCode}:meta`, "customQuestions", JSON.stringify(list) ); io.to(roomCode).emit("room_updated", await getFullRoom(roomCode)); }); socket.on("remove_custom_question", async ({ roomCode, questionId }) => { const room = await getRoomWithCleanup(roomCode); if (!room) return; const list = room.customQuestions.filter((q: any) => q.id !== questionId); await pubClient.hSet( `room:${roomCode}:meta`, "customQuestions", JSON.stringify(list) ); io.to(roomCode).emit("room_updated", await getFullRoom(roomCode)); }); //disconnect socket.on("disconnect", async () => { const code = socket.data.roomCode; if (!code) return; const playerKey = `room:${code}:players`; const metaKey = `room:${code}:meta`; // 1. Get current players to identify the leaving player const playersRaw = await pubClient.hGetAll(playerKey); const players: Player[] = Object.values(playersRaw).map((p) => JSON.parse(p) ); const idx = players.findIndex((p) => p.id === socket.id); if (idx === -1) return; const leavingPlayer = players[idx]; const wasHost = leavingPlayer.isHost; // 2. Remove leaving player from Redis await pubClient.hDel(playerKey, socket.id); await pubClient.del(`player:${code}:${socket.id}`); // 3. Get room metadata to handle turn logic const meta = await pubClient.hGetAll(metaKey); let currentIdx = parseInt(meta.currentPlayerIndex || "0"); // 4. Fetch remaining players const remainingPlayersRaw = await pubClient.hGetAll(playerKey); const remainingPlayers: Player[] = Object.values(remainingPlayersRaw) .map((p) => JSON.parse(p)) .sort((a, b) => (a.isHost === b.isHost ? 0 : a.isHost ? -1 : 1)); // Check if room is empty if (remainingPlayers.length === 0) { await pubClient.del([metaKey, playerKey]); return; } // if leaving player was the host, reassign host if (wasHost) { remainingPlayers[0].isHost = true; await pubClient.hSet( playerKey, remainingPlayers[0].id, JSON.stringify(remainingPlayers[0]) ); io.to(code).emit("new_host_toast", { name: remainingPlayers[0].name }); } if (idx === currentIdx) { // The active player left. Move to next player. // If they were the last in the list, loop back to 0. currentIdx = currentIdx % remainingPlayers.length; // If it was the active player's turn, we also reset the "flipped" state // so the new player starts with a fresh card. await pubClient.hSet(metaKey, "isFlipped", "false"); } else if (idx < currentIdx) { // Someone before the active player left. // Shift index down by 1 to keep the pointer on the same person. currentIdx = Math.max(0, currentIdx - 1); } // Save the updated index await pubClient.hSet( metaKey, "currentPlayerIndex", currentIdx.toString() ); // 5. Final Sync const finalRoom = await getFullRoom(code); io.to(code).emit("player_left", { leavingPlayer, room: finalRoom }); io.to(code).emit("room_updated", finalRoom); }); }); }; how do i break this code into funcs it is too bulky
